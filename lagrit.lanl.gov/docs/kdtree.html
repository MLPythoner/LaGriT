<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="Author" CONTENT="Jan Wills">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.05C-SGI [en] (X11; I; IRIX 6.5 IP32) [Netscape]">
</HEAD>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000EE" VLINK="#551A8B" ALINK="#FF0000">
<B><FONT SIZE=+1></FONT></B>&nbsp;
<BLOCKQUOTE><FONT FACE="Times New Roman,Times"><B><U>KDTREE&nbsp;</U></B></FONT>
<BLOCKQUOTE><B>KDTRE</B>E uses the elements of the current mesh object
to produce a k-D tree that is stored in the attributes LINKT and SBOX that
are appended to the mesh object.&nbsp; Leaf nodes in LINKT each contain
exactly one element index.&nbsp;&nbsp; Because of the possibility of triangle
overlap, <B>KDTREE</B> also produces an array SBOX which gives 'safety
boxes'.&nbsp; For each node in the k-D tree, there is a corresponding safety
box which is just big enough to contain all the triangles&nbsp; "under"
the node.&nbsp; The attributes LINKT and SBOX are used by the subroutine:&nbsp;
RETRIEVE_WITHIN_EPS.&nbsp; RETRIEVE_WITHIN_EPS finds all elements with
epsilon of the query point (xq,yq,zq). What is actually returned is a small
subset of leaves&nbsp; (i.e., elements) that feasibly could be within epsilon
of the query point.&nbsp; The user must then do exact geometric tests on
this small subset to actually determine which elements are a distance epsilon
from the query point.
<BR>&nbsp;
 
<P>subroutine retrieve_within_eps(xq,yq,zq,linkt,sbox, eps,nefound,iefound,ierr)</BLOCKQUOTE>
</BLOCKQUOTE>
 
<BLOCKQUOTE>
<BLOCKQUOTE>
<TABLE COLS=2 WIDTH="50%" NOSAVE >
<TR NOSAVE>
<TD NOSAVE>xq, yq, zq&nbsp;</TD>
 
<TD>coordinates of query point</TD>
</TR>
 
<TR>
<TD>linkt, sbox</TD>
 
<TD>mesh object KDTREE attributes created by the KDTREE command</TD>
</TR>
 
<TR>
<TD>eps&nbsp;</TD>
 
<TD>search epsilon</TD>
</TR>
 
<TR NOSAVE>
<TD NOSAVE>nefound&nbsp;</TD>
 
<TD>number of elements found</TD>
</TR>
 
<TR>
<TD>iefound</TD>
 
<TD>array of elements found</TD>
</TR>
 
<TR>
<TD>ierr</TD>
 
<TD>error flag&nbsp;&nbsp; (0 = no error)</TD>
</TR>
</TABLE>
&nbsp;
<BR>The attributes LINKT and SBOX may also be used by the subroutine: NEARESTPOINT.&nbsp;
NEARESTPOINT uses the k-D tree structure for a triangular surface mesh
object&nbsp; (generated by KDTREE) to accelerate finding the nearest point
on the surface to the given query point (xq,yq,zq).&nbsp; What is actually
returned is a small subset of leaves (i.e., triangles) that feasibly could
contain the nearest point.&nbsp; The user must then do exact geometric
tests on this small subset to determine points of intersection.
<BR>&nbsp;
<BR>&nbsp;subroutine nearestpoint(xq,yq,zq,xic,yic,zic,itet,xs,ys,zs, linkt,sbox,eps,distpossleaf,mtfound,itfound,ierr)
<BR>&nbsp;
<TABLE COLS=2 WIDTH="50%" NOSAVE >
<TR NOSAVE>
<TD NOSAVE>xq, yq, zq&nbsp;</TD>
 
<TD>coordinates of query point</TD>
</TR>
 
<TR NOSAVE>
<TD NOSAVE>xic,yic,zic</TD>
 
<TD NOSAVE>arrays of coordinates of nodes in the surface mesh object</TD>
</TR>
 
<TR>
<TD>itet</TD>
 
<TD>array containing trianged-node relationship for surface mesh object.</TD>
</TR>
 
<TR NOSAVE>
<TD NOSAVE>xs,ys,zs</TD>
 
<TD>coordinates of previous retrieved "nearestpoint".&nbsp; If there is
no previous query, set these to a very large value</TD>
</TR>
 
<TR>
<TD>linkt, sbox</TD>
 
<TD>mesh object.&nbsp; KDTREE attributes created by the KDTREE command</TD>
</TR>
 
<TR>
<TD>distpossleaf</TD>
 
<TD>work array of length = number of triangles in the surface mesh.</TD>
</TR>
 
<TR>
<TD>mtfound</TD>
 
<TD>number of triangles found</TD>
</TR>
 
<TR>
<TD>itfound</TD>
 
<TD>array of triangle (element number) found</TD>
</TR>
 
<TR>
<TD>ierr</TD>
 
<TD>error flag</TD>
</TR>
</TABLE>
&nbsp;
<BR>&nbsp;</BLOCKQUOTE>
&nbsp;
<BR>&nbsp;
<BLOCKQUOTE>&nbsp;
<BR>&nbsp;
<BR>&nbsp;
<BR>&nbsp;</BLOCKQUOTE>
</BLOCKQUOTE>
 
</BODY>
</HTML>
